mainmenu "RTAI/x86_64 configuration"

source "base/arch/Kconfig.hidden"

menu "General"

source "base/arch/Kconfig.general"

choice
	optional
	prompt "Private maintainer profiles"
	depends on RTAI_MAINTAINER

config RTAI_MAINTAINER_NONE
	bool "Use standard settings"

config RTAI_MAINTAINER_PMA
	bool "Use settings from mantegazza()aero!polimi!it"

endchoice

choice
	prompt "Inlining mode of user-space services"
#	depends on RTAI_EXTENDED
	help
	Allows choosing among:
	- Eager inlining:       i.e. static inline, always inline regardless
	  of compiler's optimization switch;
	- Never inline:         i.e. user-space services are linked to
	  programs against the appropriate support library (e.g. liblxrt.a
	  for user space RTAI syscall services).
#	- Conditional inlining: i.e. extern inline, depends on compiler's
#	  optimization switch;

config RTAI_LXRT_STATIC_INLINE
	bool "Eager inlining"
	help

#config RTAI_LXRT_EXTERN_INLINE
#	bool "Conditional inlining"
#	help

config RTAI_LXRT_NO_INLINE
	bool "No inlining"
	help

endchoice

endmenu

menu "Machine (x86_64)"

#config RTAI_DONT_DISPATCH_CORE_IRQS
#	bool "Direct vectoring of RTAI native interrupts"
#	depends on RTAI_EXTENDED
#	# to be restored later?
#	# default y
#	default n
#	help
#	RTAI dispatches real time interrupts immediately to achieve as
#	low a overhead as possible. Very important on low end CPUs. By
#	setting this option it is possible to achieve a further improvement
#	by allowing hard RTAI internal timers and SMP interprocessor
#	scheduling interrupts to be vectored directly to their handlers,
#	i.e without any dispatching overhead. A must on low end CPUs.

config RTAI_FPU_SUPPORT
	bool "Enable FPU support"
	default y
	help
	The FPU executes instructions from the processor's normal
	instruction stream. It can handle the types of high-precision
	floating-point processing operations commonly found in
	scientific, engineering, and business applications.  Enabling
	FPU support on a platform providing this hardware component
	may greatly improve performances.  You can obtain more
	information about Float-Point Unit on i386 platform on
	internet at the following URL:
	http://www.intel.com/design/intarch/techinfo/Pentium/fpu.htm

config RTAI_CPUS
	string "Number of CPUs (SMP-only)"
	default 2
	help
	RTAI has native support for Symmetrical Multi-Processing
	machines. If it is your case, you may want to enter here the
	number of CPUs of your motherboard.

	PAY ATTENTION: the default value is 2.

#config RTAI_DIAG_TSC_SYNC
#	bool "Diagnose out of sync MP-TSCs"
#	default n
#	help
#	Check alignement of MP-TSCs, against a master CPU, and show them in
#	the RTAI HAL proc file system (in TSC count units).
#
#config RTAI_MASTER_TSC_CPU
#	depends on RTAI_DIAG_TSC_SYNC
#	string "Define the master CPU for aligning MP-TSCs"
#	default 0
#	help
#	Master CPU for diagnosis and correction of TSCs alignement.
#
#config RTAI_TUNE_TSC_SYNC
#	depends on RTAI_DIAG_TSC_SYNC
#	bool "Tune out of sync MP-TSCs"
#	default n
#	help
#	Use offsets made available by enabling the out of sync diagnosis to
#	keep readings of TSCs times as aligned as possible.
#
endmenu

menu "Base system"

menu "Scheduling options"

#	depends on RTAI_EXTENDED

source "base/arch/Kconfig.sched"

config RTAI_RTC_FREQ
	string "Set RTC clock tick frequency and use RTC as the only timer"
	default 0
	help
	1 - Are you happy of working in periodic mode?
	2 - If so, is it accepable to resolve your timing needs with a
	    tick within a frequency that can be varied just in powers of
	    2, from 2 to 8192 Hz?
	If both your answers are YES than it might be worth setting your
	tick frequency of choice here and let RTAI schedulers work with
	it using the Real Time Clock (RTC). Be careful though as:
	- you must not have configured the RTC as available to Linux;
	- RTC will be the only available timer and its tick frequency
	  can be modified only here, so you must reconfigure this param
	  to change it, setting it to zero to return using the other
	  RTAI timers.
	The main advantage of using the RTC, if constraints 1 and 2 can be
	accepted, is that you will not touch any of the hard timing sources
	used by Linux (8254 especially and APIC too). In fact if an APIC
	timer is available (SMP and recent machines) it is possible to avoid
	the most important interference with Linux timing by not using the
	8254. However such a possibilty is not available on low end CPUs
	and embedded systems for which the only way to avoid interfering with
	the Linux timer might be this option. Thus in such cases, 1-2 above
	being acceptable once more, setting this config param might be a
	good choice.

config RTAI_LONG_TIMED_LIST
	bool "Use a binary tree ordering for RTAI schedulers timed lists."
	default n
	help
	RTAI schedulers use a simple ordered linear list for suspended timed
	tasks by default. By enabling this option a binary sort type ordering
	is used. Such a scheme requires far less, albeit far more complex,
	operations to set up a time ordered list of wake up times. So when
	one has not so many tasks on the timed lists this option might not
	be worth having. The actual threshold value depends on many factors,
	CPU power being the main one. So it is up to you to make a choice.
	If you have many tens or even hundred(s) of timed tasks then it is
	likely that it might be worth enabling this option.

config RTAI_SCHED_8254_LATENCY
	string "8254 tuning latency (ns)"
	default 4700
	help
	The anticipation time to be used to program the hard timer, in oneshot
	mode, for the next scheduling shot in order to compensate for the
	programming overhead needed to determine the right firing time.
	This parameter has no effect when the periodic mode is used.

config RTAI_SCHED_APIC_LATENCY
	string "APIC tuning latency (ns)"
	default 3944
	help
	The anticipation time to be used to program the hard timer, in oneshot
	mode, for the next scheduling shot in order to compensate for the
	programming overhead needed to determine the right firing time.
	This parameter has no effect when the periodic mode is used.

config RTAI_MONITOR_EXECTIME
	bool "Track RTAI task execution times"
	default y
	help
	If this option is enabled, RTAI will keep track of time consumed by
	hard real time tasks.

	** Since this option uses the TSC it is better to avoid it in production
	for x86 CPUs not having TSCs, i.e. 486s and some untrue 586s. **

	This option also enables display of execution time of tasks, per thousand
	of the total time available, in the output of the RTAI scheduler proc file,
	e.g. "cat /proc/rtai/scheduler".

config RTAI_ALLOW_RR
	bool "Allow round-robin scheduling"
	default y
	help
	By enabling this option it is possible to use round robin scheduling
	in RTAI, after enabling such a mode on a task by task basis through a
	call to a suitable scheduler function.

config RTAI_FULL_PRINHER
	bool "Enable full priority inheritance"
	default n
	help
	In RTAI resource semaphores, aka mutexes, support two ways to
	manage priority inheritance, both for resource semaphores and
	intertask messages, blocked sent or rpced, to a task owning any
	resource semaphore already. Notice in fact that the task itself
	becomes a kind of "de facto" resource when any task blocks on it
	to exchange messages.
	Without enabling this option a task owning any resource will
	recover its base priority only when it releases the very last
	resource it owns. So full priority inheritance will work as
	it is usually expected for a singly owned resource only because,
	whenever a task achieves the ownership of more than one resource,
	priority inheritance will become an adaptive dynamic priority
	ceiling. In such a case in fact the task priority is increased
	according to the highest priority task waiting on any resource
	a task owns, itself included because of messages being exchanged
	with it, but it will be returned to its base priority only when all
	owned resources are released. This is a compromise design choice
	aimed at avoiding searches for the new priority to be inheredited
	across multiply owned resources and blocked tasks send/rpcing to
	the task.
	By enabling this configuration option instead you'll allow full
	priority inheritance, so that when a task releases any resource
	semaphore it owns it will acquire the priority of the most prioritary
	task, either waiting on any resource semaphore that it is still
	owned by the task or blocked send/rpcing to it.
	The choice is dependent on your needs mostly. Just take into account
	that the default dynamic priority ceiling is simpler, a bit more
	effective and less deadlock prone than full priority inheritance.

config RTAI_BUSY_TIME_ALIGN
	bool "Busy wait to ensure resume time alignment"
	default n
	help
	In oneshot mode there is a calibrated anticipation of the timer
	firing to compensate for the time consumed in scheduling.
	Sometimes, either because of a bad calibration or purposely, it is
	possibile to anticipate the scheduling by setting a larger than needed
	anticipation. In such cases with this option one can be sure to
	achieve the desired scheduling time at the expense of waisting
	processor time. Useful when there is enough computational power to
	waist in favour of precise schedule deadlines.
	Do not set it if a hard periodic timer is to be used.

#config RTAI_LXRT_USE_LINUX_SYSCALL
#	bool "Use Linux syscall mechanism for RTAI calls from user space"
#	# to be restored later?
#	# default n
#	default y
#	help
#	With this option enabled, RTAI uses the Linux syscall mechanism
#	for its service calls, including RTAI own srqs, as provided by libc
#	"syscall".  This may improve signal handling (and therefore debugging
#	of RTAI applications), but has the drawback of a slight overhead.
#
#	When direct inlining of RTAI syscalls is enabled, see the related
#	configuration options, it is still possible to force the use of
#	the Linux syscall mechanism, even if this configuration parameter
#	has not been set. Notice that RTAI own srqs are inlined always.
#	So, since it all depends on the definition of the USE_LINUX_SYSCALL
#	macro, the only thing to do is to add:
#	#define USE_LINUX_SYSCALL
#	after all of the RTAI headers inclusion in any source file in which
#	you want to use the Linux syscall mechanism, to be sure that the macro
#	USE_LINUX_SYSCALL will not be redifined afterward. In the same way
#	when this parameter is set you can selectively revert to RTAI own
#	syscall mechanism by defining:
#	#undef USE_LINUX_SYSCALL
#	after all of the RTAI headers inclusion in any source file in which
#	you want to use the LXRT syscall mechanism.
#	RTAI will then operate in mixed mode selectively by using both
#	its own and Linux syscall mechanisms.
#
#	If in doubt, say no.

config RTAI_ALIGN_LINUX_PRIORITY
	bool "Keep Linux task priority aligned to RTAI"
	default n
	help

	By enabling this option the RTAI scheduler will keep Linux tasks
	execution priority aligned to its. Naturally this makes sense
	either for Linux soft real time tasks enabled to use RTAI APIs,
	i.e. they issued rt_task_init/rt_task_init_schmod, or when RTAI
	hard real time tasks are given back to Linux.

config RTAI_ONE_SHOT
	bool "One-shot timer mode"
	default n
	help
	Set to enable one-shot timer mode as the default. If not set, the
	hard timer will run in periodic mode according to the period used
	in start_rt_timer().
	Notice that whatever the default setting chosen it is possible to
	override it by specifically calling either rt_set_oneshot_mode() or
	rt_set_periodic_mode() at run time.

config RTAI_CAL_FREQS_FACT
	string "Cure loosely calibrated frequencies - see help"
	default 0
	help
	This configuration parameter is meaningful for the oneshot mode only
	where it has two effects:
	1 - in oneshot mode using the APIC timer, i.e. always for SMP, a
	precise scheduling time depends also on the ratio cpu_freq/apic_freq.
	The best results can be achieved by using the RTAI calibration tool.
	If no calibration is run one will rely on what Linux makes available
	by default, which could be not precise enough, especially for not so
	short timed intervals.
 	That leads to large and systematic latencies, especially in the case
	of low frequency schedules. By setting this option to a suitable
	value one can be sure that a certain firing frequency is granted
	even when relatively large idle periods are enconuntered, thus
	limiting the overall latency with which long sleeping tasks might
	be awaken in case of unprecise calibrations of the above cited
	frequencies;
	2 - in the case of very long timed list it will limit the search
	for the next firing time of widely scattered tasks with lowest
	priorities, thus avoiding useless scheduling delays. The granted
	firing interval will be roughly equal to:
	1.0/(RTAI_CAL_FREQS_FACT + 2.0) (seconds).

endmenu

menu "Supported services"

source "base/arch/Kconfig.services"

config RTAI_NETRPC
	tristate "Net RPC"
	depends on RTAI_MSG
	default y if RTAI_MSG=y
	default m if RTAI_MSG=m
	help
	RPC means Remote Procedure Call. The NetRPC implementation
	corresponds to a synchronous intertask message passing which
	is the old concept and the basis of microkernels, either
	distributed or not.  Using NetRPC makes from RTAI a
	distributed system, both for kernel and user space
	applications.
	NetRPC depends on a messaging support, if none is provided it relies
	on Linux network services, thus loosing strict real time. See the
	RTNet emulation option.
	The NetRPC module will be called rtai_netrpc.o.

config RTAI_NETRPC_RTNET
	bool "Use RTNet"
	depends on RTAI_NETRPC
	default n
	help
	This enable support of RTNet in NETRPC. By setting this parameters hard
	real time will use RTNet automatically, while soft real time task will
	use Linux networking. With this parameter set the making of RTAI will
	work even if RTNet is not installed but you'll need RTNet to run it.
	Notice that the initial linking and set up of remote port stubs is
	done in soft mode always.

config RTAI_SHM
	tristate "Shared memory"
	default m
	help
	This RTAI specific module allows sharing memory inter-intra
	real-time tasks and Linux processes. In fact it can be an
	alternative to the SYSTEM V shared memory. It may also be
	noticed that the services are symmetrical, i.e. the same calls
	can be used both in real-time tasks (within the kernel) and
	Linux processes.
	The module will be called rtai_shm.o.

config RTAI_RT_POLL
	bool "Enable IPCs polling"
	depends on RTAI_SEM
	default n
	help
	This enable polling support for RTAI services. At the moment only
	MBXes and SEMs are supported. The related service is embedded in
	the semaphores module.
	services.

config RTAI_RT_POLL_ON_STACK
	bool "Use the stack for rt_poll dynamic arrays"
	depends on RTAI_RT_POLL
	default n
	help
	This let rt_poll alloc its dynamic data directly on the stack. It is
	likely the most effective way but it can deplete the stack somewhat,
	especially on 64 bits architectures, if polling requests are large,
	say > 40. Notice that even with smaller polling sizes it might be
	important to limit stack usage also when heavy preemptions, very high
	task switching rates and interrupts floodings are expected.
	By disabling this parameter RTAI will use its real time memory
	allocation; with it the limits are just in the size you set for the
	RTAI dynamic heap and in a slightly greater overhead. So for reasons
	of cautiousness the default setting is not to use the stack.

config RTAI_CLOCK_REALTIME
	bool "Support for Posix CLOCK_REALTIME APIs"
	default y
	help
	The purpose here is mainly to activate the CLOCK_REALTIME timing
	support in a few RTAI native services used behind POSIX APIs.
	CLOCK_REALTIME is the default POSIX timing option so it should be
	enabled for a full POSIX support but, if you are either not using
	POSIX or can work with it using just the CLOCK_MONOTONIC timing,
	it would be better to avoid enabling this option. It will save you
	a test on a long long. Not too much of an overhead indeed, but why
	paying for it if not needed?
	It is defaulted to "yes" just to stay on the safe side.

endmenu

menu "Other features"

config RTAI_USE_NEWERR
	bool "New return values of blocking RTAI APIs"
	default n
	help
	Return values for RTAI blocking APIs are a bit sketchy. That
	is due to a long standing legacy dating back to DOS and 8 bits PCs,
	when saving a few "if"s might have been important. Whatever one's
	opinion such a legacy has now been likely inheredited by many well
	working existing RTAI applications, that might break with a new
	error return scheme. In any case a better set of error return values
	might be useful nowadays, so it has been added. With it one will be
	able to correctly infer more detailed reasons for error returns i.e.:
	- invalid requests (RTE_OBJINV),
	- async unblocking (RTE_UNBLKD),
	- timeouts (RTE_TIMOUT),
	- timer overruns (RTE_TMROVRN),
	- deletion of blocking objects (RTE_OBJREM).
	Thus the new scheme has been made configurable to allow RTAI users
	to choose what to do, without forcing any adaption for already
	existing working applications.

config RTAI_IMMEDIATE_LINUX_SYSCALL
	bool "Immediate Linux syscall in hard real time"
	default n
	help
	This parameter allows to control RTAI behaviour when a Linux syscall
	is made while in hard real time, according to the following two ways:
	- 1) 	- if it is set RTAI will put the task back into Linux hands,
		  i.e pass it to soft mode;
		- call the related sys service immediately, i.e. without
		  going through the Linux syscall path;
		- put the task back to hard real time, so that it will return
		  to user space in hard real time mode again.
	- 2) 	- if it is not set RTAI will put the task back into Linux hands,
		  i.e pass it to soft mode;
		- call the related sys service through the Linux syscall path;
		- return to user space in soft real time mode;
		- resume hard real time at the next call of an RTAI function.
	The most efficient behaviour is 1 but 2 can be useful in relation to
	specific RTAI users extensions.
	It is remarked that nothing is changed if hard/soft transitions
	are called controlled by an application task through
	rt_make_hard_real_time/rt_make_soft_real_time.

source "base/arch/Kconfig.other"

config RTAI_USE_TLSF
	bool "Allocate memory using TLSF in place of BSD one"
	depends on RTAI_MALLOC
	default n
	help
	RTAI dynamic memory allocation support offers two different methods
	to allocate memory chunks. The default one is along the lines
	illustrated in:
	"Design of a General Purpose Memory Allocator for the 4.3BSD Unix
	 Kernel" by Marshall K. McKusick.
	By enabling this option the:
	"Two Levels Segregated Lists (TLSF)" as found at:
	http://rtportal.upv.es/rtmalloc/allocators/tlsf/
	will be used instead.
	Rough measures seems to indicate small differences between the two
	in term of alloc/free times, likely with BSD being better for the
	tested allocation sizes (up to a few KBs), but TLSF seems to have
	better, i.e. lower, fragmentation properties. In any case you should
	check it yourself within your own applications.

config RTAI_MALLOC_HEAPSZ
	string "Size of the global heap (Kbytes)"
	depends on RTAI_MALLOC
	default 2048
	help
	RTAI pre-allocates a global heap as part of its initialization
	chores. This parameter allows to define its size (in
	kilobytes).

config RTAI_KSTACK_HEAPSZ
	string "Size of stacks heap for RTAI own kernel tasks (Kbytes)"
	depends on RTAI_MALLOC
	default 512
	help
	RTAI pre-allocates a heap for the stacks of its own kernel tasks.
	This parameter allows to define its size (in kilobytes).

config RTAI_TASK_SWITCH_SIGNAL
	bool "task switches specific signal"
	default n
	help
	RTAI can signal a task switch each time a task resumes execution.
	The way it is done depends on the execution space:
	- kernel: execute a function assigned at rt_task_init or by calling
	  rt_task_signal_handler;
	- user: install an RTAI own signal handler and have it called at any
	  task switch through its number, assigned by calling
	  rt_task_signal_handler.
	The default is to not make available this feature, so you must enable
	it explicitly if it is useful for your application.

config RTAI_TRACE
	bool "LTT support"
	default n
	help
	Originally, the Linux Trace Toolkit is a suite of tools
	designed to extract program execution details from the Linux
	operating system and interpret them. Specifically, it enables
	to extract processor utilization and allocation information
	for a certain period of time. It is then possible to perform
	various calculations on this data and dump this in a text
	file. This tool is enhanced by a GTK GUI which allows an easy
	exploitation of those results.  The Linux Trace Toolkit has
	been natively integrated into RTAI modules.
	You may refer to http://www.opersys.com/LTT/ for more information.

config RTAI_USI
	bool "User-space interrupts"
	default n
	help
	RTAI examples are available to show managing interrupts in user
	space, e.g: resumefromintr in "showroom" CVS (kernel/user/netrpc),
	"pressa" in "showroom" (user); but all of them require installing
	a proper handler in kernel space, to wake up a hard real-time user
	space task.
	The user space interrupt support does much of the same, but adds
	something that permits you to write nothing in kernel space.
	The module will be called rtai_usi.o.

config RTAI_LEDS
	tristate "LEDS-based debugging support"
	default n
	help
	The module will be called rtai_leds.o.

endmenu

endmenu

menu "Add-ons"

source "base/arch/Kconfig.addons"

config RTAI_COMEDI_LXRT
	bool "Real Time COMEDI support in user space"
	default n
	help
	RTAI offers a unified COMEDI interface to kernel/user space real-time
	applications. A kernel module will be built and a library will be
	provided. The kernel modules is called rtai_comedi.o and must be
	loaded if you want to use the libkcomedilxrt.a library.

config RTAI_COMEDI_DIR
	depends on RTAI_COMEDI_LXRT
	string "COMEDI installation directory"
	default "/usr/local"
	help
	You may need the COMEDI support for data acquisition to build your
	applications, such as RTAILab.
	You can set the path to COMEDI installation directory here.
	It will be found either in Linux, since 2.6.29 (circa), see README
	in "addons/comedi" for what to do in such a case, or by getting
	kcomedi from www.comedi.org, in which case RTAI needs the file
	linux/comedilib.h also.

config RTAI_USE_COMEDI_LOCK
	depends on RTAI_COMEDI_LXRT
	bool "Use COMEDI lock by default"
	default "n"
	help
	You may need the COMEDI lock for data acquisition when sharing a
	board among many users. You can lock/unlock explicitly any
	operation by calling comedi_lock/unlock yourself. By setting this
	parameter all functions needing a lock for a safe shared use are
	lock/unlocked by default. It can be useful to save a couple of
	calls to enforce locking from user space. Little is gained with it
	in kernel space.

source "base/arch/Kconfig.rtdm"

menu "Drivers"

config RTAI_DRIVERS_SERIAL
	bool "RTAI serial line driver"
	default y
	help
	The RTAI real-time serial driver.
	The module will be called rtai_serial.o.

config RTAI_DRIVERS_16550A
	bool "RTDM based 16550A driver support"
	depends on RTAI_RTDM
	default n
	help
	An alternate RTAI real-time serial driver based on RTDM.
	The module will be called rtai_16550A.o.

choice
	prompt "Hardware access mode"
	depends on RTAI_DRIVERS_16550A
	default RTAI_16550A_PIO
	help
	Allows choosing among:

	- Port based:    driver uses I/O ports, as defined by module vector
			 parameters "io=port1,port2,...".

	- Memory mapped: driver uses memory mapping, as defined by module
			 vector parameters "mem=addr1,addr2,...".

	- Whatever:      the driver can use both I/O and memory mapping, as
			 assigned by "io" and "mem" module vectors parameters,
			 but with only one mode allowed for each device e.g.:
			 "io=0x2F8,0,0x3F8 mem=0,0xe0000000,0"; for devices 1,
			 2 and 3 respectively.

config RTAI_16550A_PIO
	bool "Port based"

config RTAI_16550A_MMIO
	bool "Memory mapped"

config RTAI_16550A_ANY
	bool "Whatever port and memory mix"

endchoice

endmenu

endmenu
menu "RTAI Lab"

source "base/arch/Kconfig.lab"

endmenu
